precision mediump float;

uniform sampler2D state;
uniform sampler2D front;
uniform sampler2D back;
uniform vec2 scale;
uniform float duration;


int get(vec2 offset, sampler2D tex) {
	int checksum = 0;
    checksum += int(ceil(texture2D(tex, (gl_FragCoord.xy + offset) / scale).r));
    checksum += int(ceil(texture2D(tex, (gl_FragCoord.xy + offset) / scale).g));
   	checksum += int(ceil(texture2D(tex, (gl_FragCoord.xy + offset) / scale).b));
	return checksum;
}

float getR(vec2 offset, sampler2D tex) {
	return (texture2D(tex, (gl_FragCoord.xy + offset) / scale).r);
}

float getG(vec2 offset, sampler2D tex) {
	return (texture2D(tex, (gl_FragCoord.xy + offset) / scale).g);
}

float getB(vec2 offset, sampler2D tex) {
	return (texture2D(tex, (gl_FragCoord.xy + offset) / scale).b);
}

void main() {
	float current_back = float(get(vec2(0.0, 0.0), back));
	float current_state = float(get(vec2(0.0, 0.0), state));
	float current_front = float(get(vec2(0.0, 0.0), front));

	float r = getR(vec2(0.0, 0.0), front);
	float g = getG(vec2(0.0, 0.0), front);
	float b = getB(vec2(0.0, 0.0), front);

	float ms = duration;

	if(current_back != 0.0 || current_state != 0.0) {

		if(r >= 1.0 && g >= 1.0 && b >= 1.0) 	{r=g=b=1.0;}
		else if(b >= 1.0) 						{r+=ms;}
		else if(g >= 1.0 && r <= ms) 			{b+=ms;}
		else if(r >= ms && g >= 1.0) 			{r-=ms;}
		else if(r >= 1.0) 						{g+=ms;}
		else if(r >= ms) 						{r+=ms;}
		else 									{r=0.5;}

	} else {
		/*ms = ms*2.0;
		if(r >= ms && g >= 1.0 && b >= 1.0) 	{r=r-ms;}
		else if(b > 0.0)						{g=g+ms;b=b-ms;}
		else if(g >= 1.0 && r < 1.0)			{r=r+ms;}
		else if(g > 0.0 && r >= 1.0)			{g=g-ms;}
		else if(r > 0.0)						{r=r-ms;}
		//else {r=g=b=0.0;}*/
		r=g=b=0.0;
	}

	float r1 = (getR(vec2(1.0, 0.0), front) + getR(vec2(1.0, 1.0), front) + getR(vec2(0.0, 1.0), front) + getR(vec2(-1.0, 0.0), front) + getR(vec2(-1.0, -1.0), front) + getR(vec2(0.0, -1.0), front) + getR(vec2(1.0, -1.0), front) + getR(vec2(-1.0, 1.0), front) + (getR(vec2(0.0, 0.0), front)*4.0)) / 12.0;
	float g1 = (getG(vec2(1.0, 0.0), front) + getG(vec2(1.0, 1.0), front) + getG(vec2(0.0, 1.0), front) + getG(vec2(-1.0, 0.0), front) + getG(vec2(-1.0, -1.0), front) + getG(vec2(0.0, -1.0), front) + getG(vec2(1.0, -1.0), front) + getG(vec2(-1.0, 1.0), front) + (getG(vec2(0.0, 0.0), front)*4.0)) / 12.0;
	float b1 = (getB(vec2(1.0, 0.0), front) + getB(vec2(1.0, 1.0), front) + getB(vec2(0.0, 1.0), front) + getB(vec2(-1.0, 0.0), front) + getB(vec2(-1.0, -1.0), front) + getB(vec2(0.0, -1.0), front) + getB(vec2(1.0, -1.0), front) + getB(vec2(-1.0, 1.0), front) + (getB(vec2(0.0, 0.0), front)*4.0)) / 12.0;

	

	gl_FragColor = vec4((r+r1)/2.0, (g+g1)/2.0, (b+b1)/2.0, 1.0);
	gl_FragColor = vec4(r, g, b, 1.0);

}

/*float r = (getR(vec2(0, 0), state)*0.125+getR(vec2(0, 0), back)*0.125)/2.0;
	float g = (getG(vec2(0, 0), state)*0.125+getG(vec2(0, 0), back)*0.125)/2.0;
	float b = (getB(vec2(0, 0), state)*0.125+getB(vec2(0, 0), back)*0.125)/2.0;


	//gl_FragColor = vec4((r*0.95)-0.05, (g*0.95)-0.05, (b*0.95)-0.05, 1.0);

	//reinforce (take from moore)

	float r1 = ((getR(vec2(1, 0), front) + getR(vec2(1, 1), front) + getR(vec2(0, 1), front) + getR(vec2(-1, 0), front) + getR(vec2(-1, -1), front) + getR(vec2(0, -1), front) + getR(vec2(1, -1), front) + getR(vec2(-1, 1), front)) / 8.0)+((getR(vec2(1, 0), back) + getR(vec2(1, 1), back) + getR(vec2(0, 1), back) + getR(vec2(-1, 0), back) + getR(vec2(-1, -1), back) + getR(vec2(0, -1), back) + getR(vec2(1, -1), back) + getR(vec2(-1, 1), back)) / 8.0)/2.0;
	float g1 = ((getG(vec2(1, 0), front) + getG(vec2(1, 1), front) + getG(vec2(0, 1), front) + getG(vec2(-1, 0), front) + getG(vec2(-1, -1), front) + getG(vec2(0, -1), front) + getG(vec2(1, -1), front) + getG(vec2(-1, 1), front)) / 8.0)+((getG(vec2(1, 0), back) + getG(vec2(1, 1), back) + getG(vec2(0, 1), back) + getG(vec2(-1, 0), back) + getG(vec2(-1, -1), back) + getG(vec2(0, -1), back) + getG(vec2(1, -1), back) + getG(vec2(-1, 1), back)) / 8.0)/2.0;
	float b1 = ((getB(vec2(1, 0), front) + getB(vec2(1, 1), front) + getB(vec2(0, 1), front) + getB(vec2(-1, 0), front) + getB(vec2(-1, -1), front) + getB(vec2(0, -1), front) + getB(vec2(1, -1), front) + getB(vec2(-1, 1), front)) / 8.0)+((getB(vec2(1, 0), back) + getB(vec2(1, 1), back) + getB(vec2(0, 1), back) + getB(vec2(-1, 0), back) + getB(vec2(-1, -1), back) + getB(vec2(0, -1), back) + getB(vec2(1, -1), back) + getB(vec2(-1, 1), back)) / 8.0)/2.0;

*/
